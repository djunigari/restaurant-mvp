Configurar o navegador ou cliente HTTP para enviar o certificado
ğŸ”¥ Browser (local)
No Chrome ou Firefox:

Importe o client.crt no navegador como certificado pessoal.

Na hora do requestCert, o navegador automaticamente pergunta qual certificado enviar.

ğŸ”¥ Via fetch (Node ou frontend via Electron):

```
import https from 'https'

const agent = new https.Agent({
  cert: fs.readFileSync('./client.crt'),
  key: fs.readFileSync('./client.key'),
  ca: fs.readFileSync('./ca.pem'),
  rejectUnauthorized: true
})

fetch('https://localhost:3000/some-api', { agent })
```

Verificar no backend quem Ã© o cliente
VocÃª pode acessar o certificado do cliente assim:

```
server.on('secureConnection', (tlsSocket) => {
console.log('Cliente conectou com CN:', tlsSocket.getPeerCertificate().subject.CN)
})
```

No NextRequest do Next.js vocÃª nÃ£o tem isso nativamente, mas no custom server (server.js) vocÃª pode injetar no req e passar para o Next.

E no middleware do Next?
NÃ£o dÃ¡ para usar mTLS no middleware.ts do Next.js porque ele roda no edge runtime (sem Node).
Mas no seu custom server HTTPS (server.js), vocÃª jÃ¡ barra as conexÃµes de quem nÃ£o tem certificado vÃ¡lido.

âœ… Assim o edge nem vÃª requisiÃ§Ãµes invÃ¡lidas â€” elas sÃ£o rejeitadas pelo HTTPS antes mesmo do Next receber.
